# -*- coding: utf-8 -*-
"""Closest pair recursion

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aOy9MADrQSyEQqQbVqbfsSa-nXOck__a
"""

import numpy as np
import sys
from math import ceil

#Función recursiva para saber la distancia mínima en todos los puntos de una lista
def minDisRecursive(quad, dmin, pos1, pos2, i, j):
  if (i <= len(quad)-2):
    if (j <= len(quad)-1):
      d = np.sqrt((quad[i][0] - quad[j][0])**2 + (quad[i][1] - quad[j][1])**2)
      if (d < dmin):
        pos1 = quad[i]
        pos2 = quad[j]
        dmin = d
      return minDisRecursive(quad, dmin, pos1, pos2, i, j+1)
    else:
      return minDisRecursive(quad, dmin, pos1, pos2, i+1, i+2)
  return (pos1, pos2, dmin)
  

#Subrutina recursiva para dividir los cuadrantes y comparar su distancias mínimas
#Va a seguir subdividiendo los cuadrantes hasta que el número de coordenadas en 
#ellos sea <=3

def recursive(Ps, dismins):
  Px = sorted( Ps, key = lambda t: (t[0], t[1]) )
  Lx = Px[ 0 : ceil(len(Px) / 2) ]
  Rx = Px[ ceil(len(Px) / 2) : len(Px) ]

  Ly = sorted(Lx, key = lambda t: (t[1], t[0]))
  Ry = sorted(Rx, key = lambda t: (t[1], t[0]))

  Lyup = Ly[ 0 : ceil(len(Ly) / 2) ]
  Lydown = Ly[ ceil(len(Ly) / 2) : len(Ly) ]
  Ryup = Ry[ 0 : ceil(len(Ry) / 2) ]
  Rydown = Ry[ ceil(len(Ry) / 2) : len(Ry) ]

  #Si la cantidad de elementos en el cuadrante es >3 entonces sigue subdividiendo
  if (len(Ryup) > 3):
    recursive(Lyup, dismins)
    recursive(Lydown, dismins)
    recursive(Ryup, dismins)
    recursive(Rydown, dismins)
  else:
    posLyu1, posLyu2, Dlyup = minDisRecursive(Lyup, dminp, 0, 0, 0, 1)
    posLyd1, posLyd2, Dlydown = minDisRecursive(Lydown, dminp, 0, 0, 0, 1)
    posRyu1, posRyu2, Dryup = minDisRecursive(Ryup, dminp, 0, 0, 0, 1)
    posRyd1, posRyd2, Drydown = minDisRecursive(Rydown, dminp, 0, 0, 0, 1)
    dismins.append([posLyu1, posLyu2, Dlyup])
    dismins.append([posLyd1, posLyd2, Dlydown])
    dismins.append([posRyu1, posRyu2, Dryup])
    dismins.append([posRyd1, posRyd2, Drydown])



dminp = sys.maxsize

Ps = [(2,  7), ( 4, 13), ( 5, 7), (10,  5), (13,  9), (15, 5),
    (17, 7), (19, 10), (22, 7), (25, 10), (29, 14), (30, 2)]
dismins = []

Pxx = sorted( Ps, key = lambda t: (t[0], t[1]) )
Pyy = sorted( Ps, key = lambda t: (t[1], t[0]) )

Phalfx = Pxx[ ceil(len(Pxx)/4) : ceil(len(Pxx)*3/4) ]
Phalfy = Pyy[ ceil(len(Pyy)/4) : ceil(len(Pyy)*3/4) ]
posPhx1, posPhx2, Dphalfx = minDisRecursive(Phalfx, dminp, 0, 0, 0, 1)
posPhy1, posPhy2, Dphalfy = minDisRecursive(Phalfy, dminp, 0, 0, 0, 1)
dismins.append([posPhx1, posPhx2, Dphalfx])
dismins.append([posPhy1, posPhy2, Dphalfy])


recursive(Ps, dismins)

print(dismins)

for i in range (len(dismins)):
  if (dismins[i][2]<dminp):
    dminp = dismins[i][2]
    posmin1 = dismins[i][0]
    posmin2 = dismins[i][1]

print(dminp, posmin1, posmin2)